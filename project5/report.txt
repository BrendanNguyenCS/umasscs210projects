1. Enter the number of hours it took you to complete the project between
   the <<< and >>> signs below (eg, <<<10>>>).

   <<<8>>>
   
2. Enter the difficulty level (1: very easy; 5: very difficult) of the project
   between the <<< and >>> signs below (eg, <<<3>>>).

   <<<3>>>

3. Provide a short description of how you approached each problem, issues you 
   encountered, and how you resolved those issues.

   Problem 1 (Brute-force Implementation)
      Approach: This problem was quite simple with one hiccup. The constructor, isSize, put, and
      get methods comprised setting variables correctly or using the built-in methods from the bst
      object class. The points Iterable method was also using the bst built in. The nearest method
      that returned a single Point2D was also simply returning the first value returned by the
      Iterable nearest method. The Iterable nearest method just used a minpq and a linked queue to
      keep track of values that are closest to the current point. I used a counter to keep track of
      how many Points are being added to the queue and k is the stopping point for a for-each loop.
      Then simply return the linked queue populated by the for-each loop.

      Issues and resolution: For the other 3 methods, I completely understood the concept of how
      they were supposed to work. For contains, I had forgotten that I could use the bst.contains
      built in instead of bst.get(p)!=null. In my mind, they should function the same but the built
      in is consistent with the other methods. Similarly, while looping through all the possible
      points in the tree, I had a long if statement that checked if the point was within the xMin,
      xMax, yMin, and yMax of the rectangle. When I got a couple of failed tests, I went back and
      realized that I could replace this check using rect's built-in contains method.

   Problem 2 (2dTree Implementation)
      Approach: I knew that this one was going to be difficult. After going through the issues I
      will describe below, the process was pretty straightforward. All the public methods were
      calling the correct private counterparts and setting the correct parameters. The points()
      method was just keeping track of the keys and nodes correctly with queues. With the private
      put method, I understood that depending on the coordinate being checked and the comparison of
      the coordinates, you know where to put the point in which child tree and what the bounds for
      it are. For example, the first case is if you are checking x coordinates and the point is less
       than the node's point, you know that you want to modify the left tree with a rectangle whose
       bounds are to the left of the node point's x coordinate. The private get was simply following
        the described algorithm. If you are checking x coordinates, for example, you know which
        child tree to check depending on the comparison and you know you want to next check y
        coordinates in the recursive call. The nearest method was also just making sure to
        understand the described algorithm.

      Issues and resolution: The main difficulty with this problem was making sure I understood the
      algorithm that is needed to solve it. Also, I was a bit confused about the structure of the
      various methods in KdTrees and how they relate to one another. But with some clarification
      from the TA and rereading the problem statement again, I realized that I was overthinking it.
      The nearest method did give me some trouble, however. For the most part it was simple but the
      pruning rule seemed to throw me in a loop. I tested some places where the pruning check could
      be placed and realized that the instructions tell you to do the check before any recursive
      call and it made sense.

4. Did you receive help from anyone? List their names, status (classmate, 
   CS210 grad, TA, other), and the nature of help received.

   Name               Status       Help Received
   ----               ------       -------------
   Kyle               TA           Clarifying structure of methods in KdTree
   ...                ...          ...

5. List any other comments here. Feel free to provide any feedback on how
   much you learned from doing the assignment, and whether you enjoyed
   doing it.

   This was a satisfying project. At first, the algorithm seemed very difficult and I didn't think
   it made any sense. But after taking some time to really understand it, things made sense and
   implementing it into code was fun.
