1. Enter the number of hours it took you to complete the project between
   the <<< and >>> signs below (eg, <<<10>>>).

   <<<8>>>
   
2. Enter the difficulty level (1: very easy; 5: very difficult) of the project
   between the <<< and >>> signs below (eg, <<<3>>>).

   <<<4>>>

3. Provide a short description of how you approached each problem, issues you 
   encountered, and how you resolved those issues.

   Problem 1 (Board Data Type)
       Approach: Board was quite difficult but everything made sense when I slowly went through it.
       The examples that were shown in the discussion session helped in visualizing the way to
       calculate both the hamming and manhattan distances. For hamming, all that needed to happen
       was looping through the 2d array and if each tiles' value wasn't equal to row-major order
       position, then it is out of position and I add to the counter. For the manhattan distance, if
        it isn't in the right order (using the same check from hamming), I found the goal position
        of that tile (integer division for the row, modulus for the column) and then find the
        difference between those 2 and add to the manhattan distance. Finding blank position was
        just looping through the array until the 0 tile was found. isSolvable() will be discussed in
         the next section. Finding the neighbors was simply checking top, bottom, left, and right
         bounds. For each, you clone and swap values based on the bound (below for top bound, above
         for bottom bound, right for left bound, and left for right bound) (my comments should
         explain this). For equals(), just check for size equality and value-by-value equality.

       Issues and resolution: The main issue with this problem was the isSolvable() method.
       Converting the 2d array to the 1d array in row major order was quite easily. But I didn't
        understand the conditions of solvability of a board. At first, I thought that the invariance
         of the inversion count alone could determine this condition. Reading the pdf, I understood
         that if the board size was odd, then the inversion count couldn't be odd. But if it was
         even, then the invariance of the sum between the blank position row and the inversion count
          mattered. I used the same row calculation as before and then did the math (sum can't be
          even). Once I understood the conditions of solvability, the implementation made sense.

   Problem 2 (Solver Data Type)
       Approach: Interestingly, this problem was pretty smooth other than 1 small part of the
       constructor. Starting with the SearchNode internal class, it was simply following the pdf.
       The constructor was initializing the instance variables and the compareTo method was just
       using the Integer.compare method on the sums of the manhattan distance and number of moves
       for the 2 SearchNodes. The beginning of the constructor went smoothly, checking corner cases,
        initializing the instance variables, declaring and initializing the queue, and inserting the
         initial board into the queue. The rest I'll take about in the next section.

       Issues and resolution: The last part of the constructor consisted of a while loop as long as
       the queue wasn't empty. To put things simply, I had forgotten a pretty simple concept that
       made the entire file fail. After pulling the minimum for the queue, I checked if that board
       was the goal board and pushed said board into the solution instance variable and set the
       moves instance variable to that node's moves variable. If it wasn't the goal, then loop
       through the neighbors of the current board. I had put in the check if the neighbor wasn't
       equal to the previous board and inserted it with a new SearchNode if it wasn't. What I hadn't
        put in was if the previous node was null, then you want to move onto the next neighbor.

4. Did you receive help from anyone? List their names, status (classmate,
   CS210 grad, TA, other), and the nature of help received.

   Name               Status       Help Received
   ----               ------       -------------
   Kyle               TA           Gave me a hint for blank position, clarified iterator loop and
                                   method run times
   ...                ...          ...

5. List any other comments here. Feel free to provide any feedback on how
   much you learned from doing the assignment, and whether you enjoyed
   doing it.

   I wasn't sure if I should put this in the issues and resolutions section for problem 1 but I
   thought the run times constraints were pretty interesting. At first, I had thought much about
   this and did the calculations for the hamming and manhattan distances in their respective methods
   . After seeing the run time requirements, I went back and saw that those 2 methods had to have a
   run time of 1 not n^2 like I had it at that time. After consulting Kyle, I realized that the
   constructor's n^2 run time requirement should've told me that all of that should've been done in
   the constructor (along with the calculation for the blank position). Overall, a good project with
    a lot of lessons that I learned.
