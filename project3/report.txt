1. Enter the number of hours it took you to complete the project between
   the <<< and >>> signs below (eg, <<<10>>>).
   
   <<<9>>>
   
2. Enter the difficulty level (1: very easy; 5: very difficult) of the project
   between the <<< and >>> signs below (eg, <<<3>>>).

   <<<3>>>

3. Provide a short description of how you approached each problem, issues you 
   encountered, and how you resolved those issues.

   Problem 1 (Autocomplete Term)
       Approach: This one was quite simple for me. The constructors were simply declaring and
       initializing the instance variables correctly (making sure I was using "this." correctly).
       The toString method was simply concatenating weight and query separated by a tab escape
       character. The compareTo method was just making sure to call String's compareTo built-in
       method correctly. The 2 internal comparators was as easy as returning their respective
       classes. The compare method in the ReverseWeightOrder comparator was simply using the Long
       object class's compare method while making sure that I reversed the Terms for the "reverse"
       functionality. I will discuss the very slight issue with the PrefixOrder comparator in the
       next section.

       Issues and resolution: Although the PrefixOrder comparator wasn't very difficult, I had a
       slight hiccup in its compare method. I had initially thought that the String class's
       substring method took the substring from the front by default. But when I got the wrong
       answers, I looked up the substring string method and realized that substring takes from the
       rear by default. So I had to use the substring method with 2 parameters for beginning index
       and ending index. And then everything worked perfectly.

   Problem 2 (Binary Search Deluxe)
       Approach: This problem was somewhat difficult at first, but I took it slow to make sure I
       understood how the binary search algorithm works in order to make implementation easier. I
       first added both of the corner cases for both methods. I started firstIndexOf by checking for
        invalid or empty array length and returning -1 if true. Then I declared and initialized
        variables for lo (equal to the index of the first element), hi (equal to the index of the
        last element), mid (not initialized yet) and the index placeholder (initialized to -1 as
        stated in the problem pdf). I then knew that I wanted to loop as long as lo and hi didn't
        overlap with each other (lo <= hi). In the body of the loop, I first initialize (which would
         become an assignment on subsequent iterations) to the midpoint index. Then I compare the
         element at mid to key, if a[mid] is higher, set lo to the index to the right of the current
          mid (meaning you check the right half). If it is less, you set hi to the index to the left
           of the current mid (meaning you check the left half). If they are equal, then I checked
           if the mid is the first element or if the element to the left of mid is less than the key
            and set index to mid and break out of the loop. Neither of those is true, that means
            that the position left is either equal or greater than the key, so I wanted to set hi to
            the index to the left of the current mid. lastIndexOf was the same concept as
            firstIndexOf but with some small changes.

       Issues and resolution: This problem wasn't very difficult, but it took a while as I wanted to
       make sure I was doing the implementation correctly. The in-class exercises helped in my
       understanding how the binary search algorithm. The only thing that I wasn't able to figure out
       was an error that I was receiving in Autocomplete that mentions that I may not be handling
       empty arrays correctly in this file. I looked back through BinarySearchDeluxe to look for the
        problem but wasn't sure where this issue came from. I believe that the issue is in
        Autocomplete but I'll talk about that in its section.

   Problem 3 (Autocomplete)
       Approach: This one was also quite simple but with one hiccup that I wasn't able to figure out
       . The constructor just consisted of the corner case, creating the new Terms array of equal
       length to the parameter, looping through to copy the parameter elements into the instance
       array and sorting using the built-in methods. I completed numberOfMatches first by using the
       methods from the previous problem to get i and j. I returned one more than the difference
       between the 2. The allMatches method was also quite quick. After the corner case, I used the
       problem 3 methods to get the first instance and the last instance of the prefix. I created
       the Term[] matches of length returned by numberOfMatches in the same class. Then I populate
       matches looping through terms elements between i and j. Then I simply returned matches after
       sorting it in reverse weight order (using the comparator).

       Issues and resolution: I ran into a small issue with dealing with empty arrays. After
       submitting on Gradescope and receiving this error, I went back to the search algorithm and
       didn't think that was the issue. I didn't have time to test it but I believe that
       Autocomplete was the problem. My belief is that I needed to modify the constructor to check
       if terms is empty (since the corner case only checks if it is null).
   
4. Did you receive help from anyone? List their names, status (classmate, 
   CS210 grad, TA, other), and the nature of help received.

   Name               Status       Help Received
   ----               ------       -------------

   ...                ...          ...

5. List any other comments here. Feel free to provide any feedback on how
   much you learned from doing the assignment, and whether you enjoyed
   doing it.

   This project was quite enjoyable to complete. It made me really understand how the binary search
   algorithm works and completing this made it easier.
